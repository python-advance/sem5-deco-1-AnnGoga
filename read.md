2. Анализ работы декоратора deprecated
Код функции:

def deprecated(func):
    
    import warnings
    
    
    code = func.__code__
    warnings.warn_explicit(
        func.__name__ + " is deprecated. ",
        category=DeprecationWarning,
        filename=code.co_filename,
        lineno=code.co_firstlineno + 1
    )
    
    return func
Описание работы: Функция-декоратор печатает предупреждение о том что декорируемая функция устарела и не рекомендована к использованию. Вывод предположительно происходит в поток error stream. При выводе предупреждения печатается также имя функции, строка в которой она была вызвана, и имя файла, содержащего вызов.

3. Момент вывода предупреждения декоратора deprecated
Предупреждение будет выведено в момент декорирования функции. То есть, даже если функция не вызывается, предупреждение все равно будет выведено в момент интерпретации строки с декорированием.

Возможно ли сделать предупреждение для других ситуаций (например, при вызове функции)? Процесс декорирования подразумевает выполнение функции-декоратора. Так как код Python интерпретируется построково, он фактически имеет точку входа в первой строчке исполняемого файла. Следовательно, если в одной из строчек будет встречено использование декоратора, то тело декоратора будет немедленно выполнено. Таким образом, предупреждения всегда будут "выбрасываться" только при исполнении функции декоратора, то есть не в момент вызова декорируемой функции.

4. Оптимизация memorized
Декоратор не работает корректно для функций с kwargs аргументами.

Пример:

def memorized(func):
  import functools
  cache = {}
  @functools.wraps(func)
  def inner(*args, **kwargs):
    # key = (args, kwargs)
    key = args + tuple(sorted(kwargs.items()))
    if key not in cache:
      cache[key] = func(*args, **kwargs)
      return cache[key]
  return inner


@memorized
def fun(a, b, **kwargs):
  pass


if __name__ == "__main__":
  fun(1, 2, {"a":3})
Вывод:

Traceback (most recent call last):
  File "main.py", line 76, in <module>
    fun(1, 2, {"a":3})
  File "main.py", line 60, in inner
    if key not in cache:
TypeError: unhashable type: 'dict'
Варианты оптимизации: В текущем варианте ключем является список аргументов функции. Как вариант, можно записывать сумму аргументов, но надо учитывать, что от перестановки мест сумма не меняется.
Может возникнуть сложность при складывании некоторых аргументов
Для нормальной работы декоратора необходимо запоминать как значения аргументов, так и их последовательность. Отсюда следует что лучшим вариантом является сохранение набора входных аргументов функции в виде массива tuple.